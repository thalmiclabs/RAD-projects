{
  "name": "myo",
  "version": "1.5.0",
  "description": "Javascript bindings for Myo",
  "main": "myo.js",
  "dependencies": {
    "ws": "^0.4.32"
  },
  "devDependencies": {},
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/thalmiclabs/myo.js.git"
  },
  "keywords": [
    "myo",
    "thalmic",
    "myojs"
  ],
  "author": {
    "name": "thalmiclabs"
  },
  "license": "ISC",
  "bugs": {
    "url": "https://github.com/thalmiclabs/myo.js/issues"
  },
  "homepage": "https://github.com/thalmiclabs/myo.js",
  "readme": "# myo.js\r\n[![NPM](https://nodei.co/npm/myo.png)](https://nodei.co/npm/myo/)\r\n\r\nMyo javascript bindings.\r\n\r\nMyo.js allows you to interact with Thalmic Labs's [Myo Gesture Control Armband](http://myo.com) using websockets. Listen for IMU, EMG, and gesture events, as well as controlling vibration and locking.\r\n\r\n\r\n# getting started\r\nYou'll need a [Myo](http://myo.com) and [Myo Connect](https://developer.thalmic.com/downloads)\r\n\r\n\tvar Myo = require('myo');\r\n\r\n\tvar myMyo = Myo.create();\r\n\tmyMyo.on('fist', function(edge){\r\n\t\tif(!edge) return;\r\n\t\tconsole.log('Hello Myo!');\r\n\t\tmyMyo.vibrate();\r\n\t});\r\n\r\n\r\n# installation\r\nOn the browser, just include the `myo.js` file in your project. `Myo` will be global.\r\n\r\nOn node.js\r\n\r\n\tnpm install myo\r\n\r\n\r\n# experimental features\r\nThe Myo is a new kind of device that requires new ways to think about human computer interaction. We'll be sharing some experimental features we're working on. You can use these by including `myo.experimental.js`. They are not guaranteed to work and may change often. You can read about the experimental features [here](experimental/README.md).\r\n\r\n\r\n\r\n\r\n# usage\r\n\r\n### creating a myo instance\r\n\r\nThe Myo.js library can be access through the `Myo` variable. This is the core library and be used to create new Myo instances, trigger global events, amongst other things. To create a new Myo object use the `Myo.create()` function. This function can two parameters: an id (used for multi-Myo support), and specific options for that Myo.\r\n\r\n\tvar myMyo = Myo.create(); //Defaults to id 0\r\n\t//Make this Myo a bit more sensitive\r\n\tvar thirdMyo = Myo.create(2, {armbusy_threshold : 10});\r\n\r\nCommands and events used with these instances are specific to that Myo. You can create Myo instances for Myo that aren't connected yet. For example if your app uses an optional second Myo, create two instances, and listen for the `connected` event on the second one to enable dual Myo support.\r\n\r\n\r\n### creating listeners\r\n\r\nMyo.js is all about events. Whenever we receive data from the Myo, we'll filter through and emit contextual events. You create listeners to these events using the `myo.on()` function.\r\n\r\n\tmyMyo.on('fist', function(edge){\r\n\t\t//Edge is true if it's the start of the pose, false if it's the end of the pose\r\n\t\tif(edge){\r\n\t\t\tenemies.crush();\r\n\t\t}\r\n\t});\r\n\tmyMyo.on('gyroscope', function(data){\r\n\t\tif(data.x > 100){\r\n\t\t\talert('Woah now!')\r\n\t\t}\r\n\t});\r\n\r\n### holding poses\r\n\r\nTo reduce the number of false positives, it's useful to react when the user holds a pose, rather than as soon as it's fired. We've provided a handy function, `myo.timer()` to make writing this as easy as possible. The function takes three parameters: A boolean to turn the timer off and on, a duration in milliseconds, and a function to run.\r\n\r\n\t//After holding thumb to pinky for 1/2 a second, the Myo will be unlocked for 2 seconds\r\n\tmyMyo.on('thumb_to_pinky', function(edge){\r\n\t\tmyMyo.timer(edge, 500, function(){\r\n\t\t\tmyMyo.unlock(2000);\r\n\t\t})\r\n\t});\r\n\r\n### locking\r\n\r\nFor more passive apps, it's useful to \"lock\" and \"unlock\" the Myo so that accidental actions aren't picked up. We provide `.lock()` and `.unlock()` functions, `lock` and `unlock` events, and a `myo.isLocked` boolean. Myo.js doesn't implement any logic for locking and unlocking the Myo, that's up to you.\r\n\r\n\t//Thumb to pinky will unlock the Myo for 2 seconds\r\n\t// Wave out will make the menu go left, only if the Myo is unlocked,\r\n\t// also resets the relock for 5 seconds\r\n\t// The Myo will vibrate on lock and unlock.\r\n\tmyMyo.on('thumb_to_pinky', function(edge){\r\n\t\tmyMyo.unlock(2000);\r\n\t});\r\n\tmyMyo.on('wave_out', function(edge){\r\n\t\tif(edge && !myMyo.isLocked){\r\n\t\t\tmenu.left()\r\n\t\t\tmyMyo.unlock(5000);\r\n\t\t}\r\n\t});\r\n\tmyMyo.on('unlock', function(){\r\n\t\tmyMyo.vibrate();\r\n\t});\r\n\tmyMyo.on('lock', function(){\r\n\t\tmyMyo.vibrate('short').vibrate('short');\r\n\t});\r\n\r\n### locking policy\r\n\r\nThe Myo now has a built in locking policy. The policy can be set by using `.setLockingPolicy`. Supported are \"none\" and \"standard\". Note that the `.lock()` call does not lock the Myo if the policy is set to \"none\"!\r\n\r\n\t//Example for setting locking policy\r\n\tmyo.on('connected', function () {\r\n\t\tmyo.setLockingPolicy('none');\r\n\t});\r\n\r\n\t// Implement your own locking. Example: (Handle locking yourself like described above!!!!)\r\n\tmyo.on('double_tap', function (edge) {\r\n\t\tif(edge){\r\n\t\t\tif(!myo.isLocked)  {\r\n\t\t\t\tconsole.log(\"Lock\");\r\n\t\t\t\tmyo.lock();\r\n\t\t\t}else {\r\n\t\t\t\tconsole.log(\"Unlock\");\r\n\t\t\t\tmyo.unlock();\r\n\t\t\t}\r\n\t\t}\r\n\t});\r\n\r\n\r\n\r\n\r\n\r\n# myo core\r\n\r\n**options** &nbsp; `Myo.options` <br>\r\nHere you can review and set the default options that will be used for each Myo instance.\r\n\r\n**myos** &nbsp; `Myo.myos` <br>\r\nAn array containing the created Myo instances indexed by their id.\r\n\r\n**create** &nbsp; `Myo.create(), Myo.create(id), Myo.create(opts), Myo.create(id, opts)` <br>\r\nCreates and returns a new Myo instance. If no `id` is provided, defaults to 0. `opts` provided will overwrite the default options.\r\n\r\n\tvar myMyo = Myo.create();\r\n\tvar thirdMyo = Myo.create(2, {armbusy_threshold : 10});\r\n\r\n**on** &nbsp; `Myo.on(eventName, callback)` <br>\r\nCreates a global listener for each Myo instance for the given event. The `callback`'s context will be the Myo instance.\r\n\r\n\tMyo.on('connected', function(){\r\n\t\tconsole.log('connected!', this.id)\r\n\t});\r\n\r\n**initSocket** &nbsp; `Myo.initSocket()` <br>\r\nCreates web socket and sets up the message listener. Called implictly whenever you create a new myo instance.\r\n\r\n**onError** &nbsp; `Myo.onError` <br>\r\n`Myo.onError` is triggered whenever Myo.js can't establish a connection to Myo Connect. This could be that it's not running, or that your API version is out of date. You can override this function with a function of your choice.\r\n\r\n\tMyo.onError = function(){\r\n\t\tconsole.log(\"Woah, couldn't connect to Myo Connect\");\r\n\t}\r\n\tMyo.create();\r\n\r\n\r\n# myo data\r\n**id** &nbsp; `myo.id` <br>\r\nStores the id of the Myo.\r\n\r\n**connect_verion** &nbsp; `myo.connect_verion` <br>\r\nStores the version of Myo Connect.\r\n\r\n**direction** &nbsp; `myo.direction` <br>\r\nStores the direction that the User is wearing the Myo. Can either be `\"toward_elbow\"` or `\"toward_wrist\"`, referencing the Thalmic logo on the device.\r\n\r\n**arm** &nbsp; `myo.arm` <br>\r\nStores which arm the Myo is being worn on. Either `\"left\"` or `\"right\"`\r\n\r\n**orientationOffset** &nbsp; `myo.orientationOffset` <br>\r\nStores the offset quaternion used with `myo.zeroOrientation()`.\r\n\r\n**lastIMU** &nbsp; `myo.lastIMU` <br>\r\nStores the last IMU object. Useful when you need to look at changes over time.\r\n\r\n**isConnected** &nbsp; `myo.isConnected` <br>\r\nStores a boolean on whether the Myo is currently connected.\r\n\r\n**isLocked** &nbsp; `myo.isLocked` <br>\r\nStores a boolean on whether the Myo is currently locked.\r\n\r\n\r\n\r\n\r\n\r\n# myo functions\r\n\r\n**on** &nbsp; `myo.on(eventName, function(arg1, arg2,...))` <br>\r\nOn sets up a listener for a specific event name. Whenever that event is triggered, each function added with `on()`, will be called with whatever arguments `trigger()` was called with. Returns a unique event id for this listener.\r\n\r\n\tmyMyo.on('fist', function(edge){\r\n\t\tif(edge)  console.log('fist pose start');\r\n\t\tif(!edge) console.log('fist pose end');\r\n\t});\r\n\r\n**trigger** &nbsp; `myo.trigger(eventName, arg1, arg2, ...)` <br>\r\nTrigger activates each listener for a specific event. You can add any additional parameters to be passed to the listener. Myo.js uses this internally to trigger events.\r\n\r\n\tmyMyo.on('foobar', function(msg){\r\n\t\tconsole.log('wooooo', msg)\r\n\t});\r\n\tmyMyo.trigger('foobar', 'ah yis!');\r\n\r\n\r\n**zeroOrientation** &nbsp; `myo.zeroOrientation()` <br>\r\nWhen called, where ever the Myo is orientated will now be the origin. This offset value will be stored at `myo.orientationOffset`.\r\n\r\n**lock** &nbsp; `myo.lock()` <br>\r\nSets `Myo.isLocked` to true and fires the `lock` event. Myo.js does nothing with `myo.isLocked`, it's up to the developer to implement locking features. For example:\r\n\r\n\tmyMyo.on('fist', function(edge){\r\n\t\tif(Myo.isLocked || !edge) return;\r\n\t\tEnemies.smash();\r\n\t});\r\n\r\n**unlock** &nbsp; `myo.unlock(), Myo.unlock(timeout)` <br>\r\nSets `Myo.isLocked` to false and fires the `unlock` event. If a `timeout` is passed in, it will call `myo.lock()` after the timeout has passed. Subsequient calls will reset the timeout.\r\n\r\n\tmyMyo.unlock(); //Will unlock the Myo indefinitely\r\n\tmyMyo.unlock(1000); //Unlocks the Myo, but will relock after 1 second\r\n\r\n**vibrate** &nbsp; `myo.vibrate(), myo.vibrate('short' | 'medium' | 'long')` <br>\r\nMakes the Myo vibrate with a given duration. Defaults to `'medium'`.\r\n\r\n**requestBluetoothStrength** &nbsp; `myo.requestBluetoothStrength()` <br>\r\nRequests the connection strength of the Myo to be sent. Listen to the `'bluetooth_strength'` event for the data.\r\n\r\n\tmyMyo.on('bluetooth_strength', function(val){\r\n\t\tconsole.log('Such strength', val);\r\n\t});\r\n\tmyMyo.requestBluetoothStrength();\r\n\r\n\r\n**streamEMG** &nbsp; `myo.streamEMG(enabled)` <br>\r\nTells the Myo to start or stop streaming EMG data. Myo.js must have a connected socket for this to work. Pass nothing or `true` to enabled it and `false` to disabled it. Listen to the `emg` event for the data. **Note:** while streaming EMG data, gesture recognition might not be at it's best. This is being fixed in the near future.\r\n\r\n\tmyMyo.on('connected', function(){\r\n\t\tmyMyo.streamEMG(true);\r\n\t});\r\n\tmyMyo.on('emg', function(data){\r\n\t\tconsole.log(data);\r\n\t});\r\n\r\nRequests the connection strength of the Myo to be sent. Listen to the `'bluetooth_strength'` event for the data.\r\n\r\n\tmyMyo.on('bluetooth_strength', function(val){\r\n\t\tconsole.log('Such strength', val);\r\n\t});\r\n\tmyMyo.requestBluetoothStrength();\r\n\r\n**timer** &nbsp; `myo.timer(on_off, duration, callback)` <br>\r\nTimer is useful for when you want a simple timeout for an action, such as holding a gesture for a period of time. `on_off` is a boolean that will create or disable the current timer with a duration of `duration` that will fire the `callback`.\r\n\r\n\t//Fires a spread_hold event if spread is held for half a second\r\n\tmyMyo.on('fingers_spread', function(edge){\r\n\t\tmyMyo.timer(edge, 500, function(){\r\n\t\t\tmyMyo.trigger('spread_hold')\r\n\t\t})\r\n\t})\r\n\r\n\r\n\r\n# events\r\nYou can create listeners to the events by using the `myo.on()` function. You can even fire your own events using `myo.trigger()`.\r\n\r\n**connected** &nbsp; `myo.on('connected', function(){ ... })` <br>\r\nFired when the Myo is successfully connected with the Myo Connect software. Populates `myo.connect_version`.\r\n\r\n**disconnected** &nbsp; `myo.on('disconnected', function(){ ... })` <br>\r\nFired when the Myo is disconnected from the Myo Connect software.\r\n\r\n**arm_synced** &nbsp; `myo.on('arm_synced', function(){ ... })` <br>\r\nFired when the User puts on the Myo and successfully does the Setup Gesture. Populates `myo.arm` and `myo.direction`\r\n\r\n**arm_unsynced** &nbsp; `myo.on('arm_unsynced', function(){ ... })` <br>\r\nFired when the User removes the Myo.\r\n\r\n**imu** &nbsp; `myo.on('imu', function(data){ ... })` <br>\r\nThis event is fired whenever we receive IMU data from the Myo. This data is grouped like this:\r\n\r\n\t{\r\n\t\torientation : {\r\n\t\t\tx : NUM,\r\n\t\t\ty : NUM,\r\n\t\t\tz : NUM,\r\n\t\t\tW : NUM\r\n\t\t},\r\n\t\tgyroscope : {\r\n\t\t\tx : NUM,\r\n\t\t\ty : NUM,\r\n\t\t\tz : NUM\r\n\t\t},\r\n\t\taccelerometer : {\r\n\t\t\tx : NUM,\r\n\t\t\ty : NUM,\r\n\t\t\tz : NUM\r\n\t\t}\r\n\t}\r\n\r\n**emg** &nbsp; `myo.on('emg', function(data){ ... })` <br>\r\nThis event is fired whenever we receive EMG data from the Myo. In order to get this data you must first tell the myo you want it to stream EMG by using the `myo.streamEMG(true)` command. This data is an 8 element array (one for each pod) bounded from -127 to 127.\r\n\r\n\tmyMyo.streamEMG(true);\r\n\tmyMyo.on('emg', function(data){\r\n\t\tconsole.log(data);\r\n\t});\r\n\r\n**gyroscope** &nbsp; `myo.on('gyroscope', function(data){ ... })` <br>\r\nThis event is fired whenever we receive gyroscopic data from the Myo. This data is grouped as 3d coordinates.\r\n\r\n**orientation** &nbsp; `myo.on('orientation', function(data){ ... })` <br>\r\nThis event is fired whenever we receive orientation data from the Myo. This data is grouped as a quanternion.\r\n\r\n**accelerometer** &nbsp; `myo.on('accelerometer', function(data){ ... })` <br>\r\nThis event is fired whenever we receive acceleration data from the Myo. This data is grouped as 3d coordinates.\r\n\r\n**bluetooth_strength** &nbsp; `myo.on('bluetooth_strength', function(data){ ... })` <br>\r\nFired after `Myo.requestBluetoothStrength()` is called. Returns a measure of the bluetooth strength the Myo is connected to.\r\n\r\n**pose** &nbsp; `myo.on('pose', function(pose_name, edge){ ... })` <br>\r\nWhenever the Myo detects a pose change it will fire a `pose` event. The listener will be called with the `pose_name` and the `edge` which will be `true` if it is the start of the pose and `false` if it is the end of the pose. Myo.js will also fire an individual event for each pose with the `edge` as the only parameter for the listener. Here is a list of all the poses : `rest`,`fingers_spread`,`wave_in`,`wave_out`,`fist`,`thumb_to_pinky`.\r\n\r\n\tMyo.on('pose', function(pose_name, edge){\r\n\t\tif(pose_name != 'rest' && edge){\r\n\t\t\tconsole.log('Started ', pose_name);\r\n\t\t}\r\n\t});\r\n\tvar myMyo = Myo.create();\r\n\tmyMyo.on('wave_in', function(edge){\r\n\t\tif(edge) Menu.left()\r\n\t})\r\n\r\n**lock** &nbsp; `myo.on('lock', function(){ ... })` <br>\r\nFired whenever `myo.lock()` is called. Useful for firing vibration events, or updating UI when the Myo becomes locked.\r\n\r\n**unlock** &nbsp; `myo.on('unlock', function(){ ... })` <br>\r\nFired whenever `myo.unlock()` is called. Useful for firing vibration events, or updating UI when the Myo becomes unlocked.\r\n\r\n**status** &nbsp; `myo.on('status', function(){ ... })` <br>\r\nFired whenever a non-pose, non-IMU, non-EMG event is fired. Useful for making debug windows, without being flooded by IMU events.\r\n\r\n\r\n# changelog\r\nReleases are documented in [changelog.md](changelog.md)\r\n\r\n# branding and assets\r\nYou can use assets provided in our [branding](https://developer.thalmic.com/branding/) and [UX](https://developer.thalmic.com/ux/) guidelines.\r\n\r\n# thanks\r\nThanks to [stolksdorf](https://github.com/stolksdorf) for creating Myo.js\r\n\r\n## license\r\n\r\nThe Myo.js project is licensed using the modified BSD license. For more details, please see LICENSE.txt.",
  "readmeFilename": "README.md",
  "_id": "myo@1.5.0",
  "_shasum": "24ff4eb5c5d593564d38f7c059f1dae60f8f2bda",
  "_from": "myo@",
  "_resolved": "https://registry.npmjs.org/myo/-/myo-1.5.0.tgz"
}
